// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller                    
// FL                   motor         1               
// FR                   motor         10              
// BL                   motor         11              
// BR                   motor         20              
// Inertial             inertial      18              
// Left                 encoder       G, H            
// FlyFront             motor         5               
// FlyBack              motor         6               
// Intake               motor         16              
// IndexPiston          digital_out   C               
// Endgame              digital_out   B               
// Indexer              motor         15              
// Pressure             digital_out   A               
// Flywheel             rotation      3               
// Angler               digital_out   D               
// Side                 rotation      2               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller                    
// FL                   motor         1               
// FR                   motor         10              
// BL                   motor         11              
// BR                   motor         20              
// Inertial             inertial      18              
// Left                 encoder       G, H            
// FlyFront             motor         5               
// FlyBack              motor         6               
// Intake               motor         16              
// IndexPiston          digital_out   C               
// Endgame              digital_out   B               
// Indexer              motor         15              
// Pressure             digital_out   A               
// Flywheel             rotation      3               
// Angler               digital_out   D               
// Side                 rotation      2               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller                    
// FL                   motor         1               
// FR                   motor         10              
// BL                   motor         7               
// BR                   motor         20              
// Inertial             inertial      18              
// Left                 encoder       G, H            
// FlyFront             motor         5               
// FlyBack              motor         6               
// Intake               motor         16              
// IndexPiston          digital_out   C               
// Endgame              digital_out   B               
// Indexer              motor         15              
// Pressure             digital_out   A               
// Flywheel             rotation      3               
// Angler               digital_out   D               
// Side                 rotation      2               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller                    
// FL                   motor         1               
// FR                   motor         10              
// BL                   motor         7               
// BR                   motor         20              
// Inertial             inertial      18              
// Left                 encoder       G, H            
// FlyFront             motor         5               
// FlyBack              motor         6               
// Intake               motor         16              
// IndexPiston          digital_out   C               
// Endgame              digital_out   B               
// Indexer              motor         15              
// Pressure             digital_out   A               
// Flywheel             rotation      3               
// Angler               digital_out   D               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller                    
// FL                   motor         1               
// FR                   motor         10              
// BL                   motor         7               
// BR                   motor         20              
// Inertial             inertial      18              
// Left                 encoder       G, H            
// Side                 encoder       E, F            
// FlyFront             motor         5               
// FlyBack              motor         6               
// Intake               motor         16              
// IndexPiston          digital_out   C               
// Endgame              digital_out   B               
// Indexer              motor         15              
// Pressure             digital_out   A               
// Flywheel             rotation      3               
// Angler               digital_out   D               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller                    
// FL                   motor         1               
// FR                   motor         10              
// BL                   motor         7               
// BR                   motor         20              
// Inertial             inertial      18              
// Left                 encoder       G, H            
// Side                 encoder       E, F            
// FlyFront             motor         5               
// FlyBack              motor         6               
// Intake               motor         16              
// IndexPiston          digital_out   C               
// Endgame              digital_out   B               
// Indexer              motor         15              
// Pressure             digital_out   A               
// Flywheel             rotation      3               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller                    
// FL                   motor         1               
// FR                   motor         10              
// BL                   motor         7               
// BR                   motor         20              
// Inertial             inertial      18              
// Left                 encoder       G, H            
// Side                 encoder       E, F            
// FlyFront             motor         5               
// FlyBack              motor         6               
// Intake               motor         16              
// IndexPiston          digital_out   C               
// Endgame              digital_out   B               
// Indexer              motor         15              
// Pressure             digital_out   A               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller                    
// FL                   motor         1               
// FR                   motor         10              
// BL                   motor         7               
// BR                   motor         20              
// Inertial             inertial      18              
// Left                 encoder       G, H            
// Side                 encoder       E, F            
// FlyFront             motor         5               
// FlyBack              motor         6               
// Vision               vision        3               
// Intake               motor         16              
// IndexPiston          digital_out   C               
// Endgame              digital_out   B               
// Indexer              motor         15              
// Pressure             digital_out   A               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller                    
// FL                   motor         1               
// FR                   motor         10              
// BL                   motor         7               
// BR                   motor         20              
// Inertial             inertial      18              
// Left                 encoder       G, H            
// Side                 encoder       E, F            
// FlyFront             motor         5               
// FlyBack              motor         6               
// Vision               vision        3               
// Intake               motor         16              
// Double1              digital_out   C               
// Endgame              digital_out   B               
// Indexer              motor         15              
// Pressure             digital_out   A               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller                    
// FL                   motor         1               
// FR                   motor         10              
// BL                   motor         7               
// BR                   motor         20              
// Inertial             inertial      18              
// Left                 encoder       G, H            
// Side                 encoder       E, F            
// FlyFront             motor         5               
// FlyBack              motor         6               
// Vision               vision        3               
// Intake               motor         16              
// Double1              digital_out   C               
// Endgame              digital_out   B               
// Indexer              motor         15              
// Pressure             digital_out   A               
// IntakePump           digital_out   D               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller                    
// FL                   motor         1               
// FR                   motor         10              
// BL                   motor         11              
// BR                   motor         20              
// Inertial             inertial      18              
// Left                 encoder       G, H            
// FlyFront             motor         5               
// FlyBack              motor         6               
// Intake               motor         16              
// IndexPiston          digital_out   C               
// Endgame              digital_out   B               
// Indexer              motor         15              
// Pressure             digital_out   A               
// Side                 rotation      2               
// Controller2          controller                    
// Flywheel             rotation      3               
// Angler               digital_out   D               
// ---- END VEXCODE CONFIGURED DEVICES ----
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*    Module:       main.cpp                                                  */
/*    Author:       LUX                                                       */
/*    Created:      Thu Sep 26 2019                                           */
/*    Description:  Competition Program                                       */
/*                                                                            */
/*----------------------------------------------------------------------------*/

// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// Controller1          controller                    
// FL                   motor         1               
// FR                   motor         10              
// BL                   motor         11              
// BR                   motor         20              
// Inertial             inertial      17              
// Left                 encoder       G, H            
// Side                 encoder       E, F            
// FlyFront             motor         5               
// FlyBack              motor         6               
// Vision               vision        3               
// Intake               motor         16              
// IndexerPiston              digital_out   C               
// Endgame              digital_out   B               
// Indexer              motor         15              
// Pressure             digital_out   A               
// IntakePump           digital_out   D               
// ---- END VEXCODE CONFIGURED DEVICES ----

#include "chassis-control.h"
#include "draw-field.h"
#include "flywheel.h"
#include <iostream>

using namespace vex;

competition Competition;

task odometryTask;
task drawFieldTask;
task chassisControlTask;
task flywheelTask;

void pre_auton(void) {
  vexcodeInit();

  Inertial.calibrate();

  while(Inertial.isCalibrating()) {
    task::sleep(100);
  }

  //roller: 180, nonroller: 270, AWP = 180
  Inertial.setHeading(180, degrees);

  wait(800, msec);
}

/*---------------------------------------------------------- HELPER METHODS ----------------------------------------------------------*/

void driveForDist(double xDist, int timeOutLength, double maxSpeed){
  directDrive(xDist, timeOutLength, maxSpeed);
  waitUntil(runChassisControl == false);
}

void turnToAngle(int targetAngle, int timeOutLength){
  turnTo(targetAngle, timeOutLength);
  waitUntil(runChassisControl == false);
}

void moveToPoint(double xPos, double yPos, int timeOutLength, double maxSpeed){
  turnToPoint(xPos, yPos, 1500, 1);
  waitUntil(runChassisControl == false);
  driveTo(xPos, yPos, 1, timeOutLength, maxSpeed);
  waitUntil(runChassisControl == false);
}

void rollFor(int timeRoll){
  Intake.spin(reverse, 60, pct);
  wait(timeRoll, msec);
  Intake.stop();
}

int targetSpeed;

void shoot(){
  waitUntil(-Flywheel.velocity(rpm) > targetSpeed -10  && -Flywheel.velocity(rpm) < targetSpeed+10);
  Indexer.setVelocity(80, pct);
  Intake.setVelocity(80, pct);
  Indexer.spin(reverse);
  Intake.spin(fwd);
  IndexPiston.set(true);
  Pressure.set(true);
  wait(400, msec);
  Pressure.set(false);
  IndexPiston.set(false);
  Indexer.stop();
  Intake.stop();
}

void shoot(int timeFor){
  waitUntil(-Flywheel.velocity(rpm) > targetSpeed-5  && -Flywheel.velocity(rpm) < targetSpeed+10);
  Indexer.setVelocity(80, pct);
  Indexer.spinFor(reverse, 250, deg);
  //Indexer.spin(reverse);
  //Intake.spin(fwd);
  //waitUntil(-Flywheel.velocity(rpm) < targetSpeed - 60);
  //wait(timeFor, msec);
  Indexer.setVelocity(100, pct);
  Indexer.spin(fwd);
  wait(100, msec);
  //Intake.stop();
}

void cycle(){
  Indexer.spin(reverse);
  Intake.spin(fwd);
  IndexPiston.set(true);
  Pressure.set(true);
  wait(1500, msec);
  Pressure.set(false);
  IndexPiston.set(false);
  Indexer.stop();
  Intake.stop();
}

/*---------------------------------------------------------- AUTONOMOUS PROGRAMS ----------------------------------------------------------*/

// SKILLS
void autonSkills() {
  FL.spinFor(reverse, 180, degrees, false);
  FR.spinFor(reverse, 180, degrees, false);
  BL.spinFor(reverse, 180, degrees, false);
  BR.spinFor(reverse, 180, degrees, true);

  Indexer.spin(reverse, 60, pct);
  wait(800, msec);
  Indexer.stop();

  FL.spinFor(fwd, 560, degrees, false);
  FR.spinFor(fwd, 560, degrees, false);
  BL.spinFor(fwd, 560, degrees, false);
  BR.spinFor(fwd, 560, degrees, true);

  turnToAngle(270, 4000);

  FL.spinFor(reverse, 650, degrees, false);
  FR.spinFor(reverse, 650, degrees, false);
  BL.spinFor(reverse, 650, degrees, false);
  BR.spinFor(reverse, 650, degrees, true);

  Indexer.spin(reverse, 60, pct);
  wait(800, msec);
  Indexer.stop();

  FL.spinFor(fwd, 360, degrees, false);
  FR.spinFor(fwd, 360, degrees, false);
  BL.spinFor(fwd, 360, degrees, false);
  BR.spinFor(fwd, 360, degrees, true);

  turnToAngle(315, 4000);
}

void rollerStart(){
  THETA_START = 0;

  driveForDist(-4.5, 800, 1);

  Indexer.spin(reverse, 100, pct);
  wait(400, msec);
  Indexer.stop();

  driveForDist(8, 1300, 1);

  turnToAngle(317, 1000);

  FlyFront.spin(reverse, 450, rpm);
  FlyBack.spin(reverse, 450, rpm);

  driveForDist(63, 2000, 1);

  turnToAngle(38, 1000);
  shoot();

  Intake.spin(fwd, 100, pct);
  Indexer.spin(fwd, 100, pct);
  wait(800, msec);

  Intake.stop();
  Indexer.stop();

  shoot();

  turnToAngle(0, 800);
  driveForDist(-45, 2000, 1);
}

void nonRollerStart(){
  THETA_START = 0;
  
  targetSpeed = 2323;
  FwVelocitySet(targetSpeed, .84);

  Intake.setVelocity(100, pct);
  Indexer.setVelocity(100, pct);

  Intake.spin(fwd);
  Indexer.spin(fwd);

  driveForDist(20, 1300, 0.5);

  turnToAngle(157.5, 1100);

  IndexPiston.set(true);
  Pressure.set(true);

  //Intake.stop();
  Indexer.stop();

  shoot(21);
  shoot(21);
  shoot(105);

  wait(40, msec);

  Pressure.set(false);
  IndexPiston.set(false);

  turnToAngle(225, 1300);

  //Intake.spin(fwd);
  Indexer.spin(fwd);

  driveForDist(34, 2000, 1);


  targetSpeed = 2307;
  FwVelocitySet(targetSpeed, .83);

  turnToAngle(135, 1300);

  IndexPiston.set(true);
  Pressure.set(true);

  //Intake.stop();
  //Indexer.stop();

  shoot(21);
  shoot(107);

  Pressure.set(false);
  IndexPiston.set(false);

  turnToAngle(233, 1000);

  driveForDist(-63, 2000, 1);

  turnToAngle(180, 800);

  driveForDist(-8, 800, 1);

  Indexer.spin(reverse, 100, pct);
  wait(400, msec);
  Indexer.stop();
}

void soloAWP(){
  THETA_START = 180;

  targetSpeed = 2510;

  //FlyFront.spin(reverse, 10.8, volt);
  //FlyBack.spin(reverse, 10.8, volt);
  FwVelocitySet(targetSpeed, .95);

  driveForDist(-4.5, 800, 1);

  Indexer.spin(reverse, 100, pct);
  wait(400, msec);
  Indexer.stop();

  driveForDist(3, 1000, 1);

  turnToAngle(181, 1300);

  shoot();
  shoot(500);

  turnToAngle(135, 1300);

  FwVelocitySet(0, 0);

  driveForDist(22.5, 2000, 1);

  Intake.spinFor(8, rev, false); 
  Indexer.spinFor(8, rev, false); 

  //Intake.spinFor(-200, degrees, false);

  targetSpeed = 2350;
  FwVelocitySet(targetSpeed, 0.83);

  driveForDist(43.5, 3000, 0.4);

  turnToAngle(217, 1300);
  
  shoot(400);
  shoot(500);
  shoot(500);

  wait(500, msec);

  FwVelocitySet(0, 0);

  turnToAngle(313, 1300);

  driveForDist(-59, 1700, 1);

  turnToAngle(270, 1300);

  driveForDist(-15, 1300, 1);

  Indexer.spin(reverse, 100, pct);
  wait(700, msec);
  Indexer.stop();
}

void skillsOne(){
  Angler.set(true);

  Intake.setVelocity(100, pct);
  Indexer.setVelocity(100, pct);

  THETA_START = 180;

  driveForDist(-6, 1000, 1);

  Indexer.spin(reverse, 100, pct);
  wait(400, msec);
  Indexer.stop();

  driveForDist(5, 1300, 1);
  // first roller done

  turnToAngle(235, 1300);

  Intake.spin(fwd);
  Indexer.spin(fwd);

  driveForDist(14, 2500, 0.5);

  // intake first disk

  turnToAngle(90, 1300);

  Intake.stop();
  Indexer.stop();

  driveForDist(-15, 2000, 1);
  
  Indexer.spin(fwd, 100, pct);
  wait(400, msec);
  Indexer.stop();

  driveForDist(2, 1000, 1);

  // second roller done
  
  FwVelocitySet(1970, 0.8);

  turnToAngle(180, 1300);

  driveForDist(75, 4000, 1);

  turnToAngle(165, 1000);

  cycle();

  FwVelocitySet(0, 0);

  turnToAngle(182, 1000);

  // first cycle done

  driveForDist(-15, 1200, 1);

  turnToAngle(90, 1300);

  Intake.spin(fwd);
  Indexer.spin(fwd);

  driveForDist(115, 6000, 0.5);

  // intake three

  FwVelocitySet(1970, 0.8);

  turnToAngle(0, 1300);

  driveForDist(35, 3000, 1);

  Intake.stop();
  Indexer.stop();

  turnToAngle(353, 1300);

  cycle();

  FwVelocitySet(0, 0);

  // second cycle done

  turnToAngle(2, 1500);

  Inertial.calibrate();

  waitUntil(!Inertial.isCalibrating());

  //Inertial.setHeading(0, degrees);

  driveForDist(-13, 2000, 1);

  turnToAngle(91, 1300);

  Intake.spin(fwd);
  Indexer.spin(fwd);

  driveForDist(117, 6000, 0.5);

  FwVelocitySet(1970, 0.8);

  turnToAngle(0, 1300);

  driveForDist(33, 3000, 1);

  turnToAngle(350, 1300);

  cycle();

  FwVelocitySet(0, 0);

  turnToAngle(0, 1300);

  // cycle three done

  driveForDist(-14.5, 1200, 1);

  turnToAngle(270, 1300);

  driveForDist(100, 5000, 0.4);

  turnToAngle(180, 1300);

  driveForDist(-65, 4000, 0.5);

  Indexer.spin(fwd, 100, pct);
  wait(400, msec);
  Indexer.stop();

  driveForDist(15, 2000, 0.5);

  turnToAngle(90, 1300);

  driveForDist(-15, 2000, 0.8);

  Indexer.spin(reverse, 100, pct);
  wait(400, msec);
  Indexer.stop();

  driveForDist(10, 1300, 0.5);

  turnToAngle(135, 1300);

  // BRUH?

  // driveForDist(-70, 4000, 1);

  // turnToAngle(270, 1300);
  
  // driveForDist(-6, 1300, 1);

  // Indexer.spin(reverse, 100, pct);
  // wait(400, msec);
  // Indexer.stop();

  // driveForDist(13, 1300, 1);

  // // third roller done

  // turnToAngle(0, 1300);
  
  // driveForDist(-15, 2000, 1);

  // Indexer.spin(reverse, 100, pct);
  // wait(400, msec);
  // Indexer.stop();

  // driveForDist(16, 1300, 1);

  // // fourth roller done

  // turnToAngle(315, 1300);

  // launch endgame!!
}

void skillsTwoCycle(){
  Angler.set(true);

  Intake.setVelocity(100, pct);
  Indexer.setVelocity(100, pct);

  THETA_START = 180;

  driveForDist(-6, 1200, 1);

  Indexer.spin(reverse, 100, pct);
  wait(400, msec);
  Indexer.stop();

  driveForDist(5, 1300, 1);
  // first roller done

  turnToAngle(235, 1300);

  Intake.spin(fwd);
  Indexer.spin(fwd);

  driveForDist(14, 2500, 0.5);

  // intake first disk

  turnToAngle(90, 1300);

  Intake.stop();
  Indexer.stop();

  driveForDist(-15, 2000, 1);
  
  Indexer.spin(fwd, 100, pct);
  wait(400, msec);
  Indexer.stop();

  driveForDist(2, 1000, 1);

  // second roller done
  
  FwVelocitySet(2000, 0.8);

  turnToAngle(180, 1300);

  driveForDist(75, 4000, 1);

  turnToAngle(162, 1000);

  cycle();

  FwVelocitySet(0, 0);

  turnToAngle(182, 1000);

  // first cycle done

  driveForDist(-14.5, 1200, 1);

  turnToAngle(90, 1300);

  Intake.spin(fwd);
  Indexer.spin(fwd);

  driveForDist(117.5, 6000, 0.5);

  // intake three

  FwVelocitySet(2000, 0.8);

  turnToAngle(0, 1300);

  driveForDist(35, 3000, 1);

  Intake.stop();
  Indexer.stop();

  turnToAngle(348, 1300);

  cycle();

  FwVelocitySet(0, 0);

  // second cycle done

  turnToAngle(4, 1300);

  driveForDist(-70, 4000, 1);

  turnToAngle(269, 1295);
  
  driveForDist(-6, 1300, 1);

  Indexer.spin(reverse, 100, pct);
  wait(400, msec);
  Indexer.stop();

  driveForDist(13, 1300, 1);

  // third roller done

  turnToAngle(0, 1300);
  
  driveForDist(-17, 2000, 1);

  Indexer.spin(reverse, 100, pct);
  wait(400, msec);
  Indexer.stop();

  driveForDist(14, 1300, 1);

  // fourth roller done

  turnToAngle(315, 1300);

  // launch endgame!!
}

/*---------------------------------------------------------- AUTONOMOUS CONTROL ----------------------------------------------------------*/

void autonomous(void) {
  Left.resetRotation();
  Side.resetPosition();

  FL.resetRotation();
  FR.resetRotation();
  BL.resetRotation();
  BR.resetRotation();
  DRIVER_CONTROL = false;

  task odometryTask(positionTracking);
  task drawFieldTask(drawField);
  task chassisControlTask(chassisControl);
  task flywheelTask(FwControlTask);

  waitUntil(!Inertial.isCalibrating());

  skillsOne();
  //skillsTwoCycle();
  //autonSkills();
  //tuning();
  //soloAWP();
  //rollerStart();
  //nonRollerStart();
}

/*---------------------------------------------------------- DRIVER METHODS ----------------------------------------------------------*/

double exponentialDrive(double controllerValue) {
  return pow(controllerValue, 3) / pow(100, 2);
}

// INTAKE

bool intakeTrue = false;
bool outTakeTrue = false;
const int intakePct = 100;

void intakeControl(){
  Intake.setVelocity( intakePct, pct);
  Indexer.setVelocity( intakePct, pct);
  if (Controller1.ButtonY.PRESSED){
    Indexer.spinFor(fwd, 400, msec);
  }
  if (Controller1.ButtonR1.pressing()){
   intakeTrue = true;
  }
  else if (Controller1.ButtonR2.pressing()){
   intakeTrue = false;
   outTakeTrue = false;
   Intake.stop();
   Indexer.stop();
  }
  if (intakeTrue){
   Intake.spin(fwd, intakePct, pct);
   Indexer.spin(fwd, intakePct, pct);
  }
  if(Controller1.ButtonB.PRESSED) {
    outTakeTrue = !outTakeTrue;
    Intake.stop();
    Indexer.stop();
  }
  if (outTakeTrue){
    Intake.spin(reverse, 100, pct);
    Indexer.spin(reverse, 100, pct);
    Controller1.rumble(".");
  }
  else {
    Intake.setStopping(coast);
    Indexer.setStopping(coast);
  }
}

// SHOOTING

void flywheelControl(){
  if (flyWheelOn){
      // FL.setBrake(brake);
      // FR.setBrake(brake);
      // BR.setBrake(brake);
      // BL.setBrake(brake);
    }
    else {
      FL.setBrake(coast);
      FR.setBrake(coast);
      BR.setBrake(coast);
      BL.setBrake(coast);
    }

    if (Controller1.ButtonL1.PRESSED){
      flyWheelOn = true;
      FwVelocitySet( 2000, 0.67 );  
    }
    if (Controller1.ButtonL2.PRESSED){
      flyWheelOn = false;
      FwVelocitySet( 0, 0 );      
    }
}

void shooterControl(){
  if (Controller1.ButtonUp.PRESSED){
    Indexer.setVelocity(100, pct);
    Intake.setVelocity(90, pct);
    
    if (flyWheelOn && -FlyFront.velocity(rpm) > 270)
    {
      Indexer.spin(reverse);
      Intake.spin(fwd);
      flywheelVoltage = 10;
      IndexPiston.set(true);
      Pressure.set(true);
      wait(1500, msec);
      Pressure.set(false);
      IndexPiston.set(false);
      Indexer.stop();
      Intake.stop();
      flywheelVoltage = 7;
    }
    else {  
      flyWheelOn = true; 
    }
  }
}

// ENDGAME

void endgameControl(){
  if (Controller1.ButtonY.pressing() && Controller1.ButtonRight.pressing()){  
    Endgame.set(true);
  }
}

// ANGLER

void anglerControl(){
  if (Controller1.ButtonDown.pressing() && Controller1.ButtonB.pressing()){  
    if (Angler.value() == true){
      Angler.set(false);
      wait(50, msec);
    }
    else {
      Angler.set(true);
      wait(50, msec);
    }
  }
}
    
/*---------------------------------------------------------- USER CONTROL ----------------------------------------------------------*/

void tuneTurns(){
  if (Controller1.ButtonX.PRESSED){
    turnkP += 1;
  }
  if (Controller1.ButtonA.PRESSED){
    turnkP -= 1;
  }
  if (Controller1.ButtonY.PRESSED){
    turnkD += 1;
  }
  if (Controller1.ButtonB.PRESSED){
    turnkD -= 1;
  }  
  
  std::cout << turnkP << std::endl << std::endl;
  std::cout << turnkI << std::endl << std::endl;
  std::cout << turnkD << std::endl << std::endl;
}

void tuneDrive(){
  if (Controller1.ButtonX.PRESSED){
    drivekP += 1;
  }
  if (Controller1.ButtonA.PRESSED){
    drivekP -= 1;
  }
  if (Controller1.ButtonY.PRESSED){
    drivekD += 1;
  }
  if (Controller1.ButtonB.PRESSED){
    drivekD -= 1;
  }  
  
  std::cout << drivekP << std::endl << std::endl;
  std::cout << drivekI << std::endl << std::endl;
  std::cout << drivekD << std::endl << std::endl;
}

void tuneFlywheel(){
  if (Controller1.ButtonX.PRESSED){
    flykP += 1;
  }
  if (Controller1.ButtonA.PRESSED){
    flykP -= 1;
  }
  if (Controller1.ButtonY.PRESSED){
    flykD += 1;
  }
  if (Controller1.ButtonB.PRESSED){
    flykD -= 1;
  }
}

void tuneTBH(){
  if (Controller1.ButtonX.PRESSED){
    gain += 0.00001;
  }
  if (Controller1.ButtonA.PRESSED){
    gain -= 0.00001;
  }

  if (Brain.Timer.value() < 10){
    std::cout << Brain.Timer.value() << "," << -Flywheel.velocity(rpm) << std::endl; 
  }

  //std::cout << gain << std::endl << std::endl;
}

void tankDrive(){
  float maxSpeed = 100;

  int exp = 3;

  float leftPct = (Controller1.Axis3.position());
  float rightPct = (Controller1.Axis2.position());

  float leftNewPct = pow(leftPct, exp)/pow(maxSpeed, exp-1);
  float rightNewPct = pow(rightPct, exp)/pow(maxSpeed, exp-1);

  FL.spin(fwd, leftNewPct, pct);
  BL.spin(fwd, leftNewPct, pct);
  FR.spin(fwd, rightNewPct, pct);
  BR.spin(fwd, rightNewPct, pct);
}

void arcadeDrive(){
  float arcadeLeftPct = (Controller1.Axis3.position() + Controller1.Axis1.position() * 0.6);
  float arcadeRightPct = (Controller1.Axis3.position() - Controller1.Axis1.position()* 0.6);

  FL.spin(fwd, arcadeLeftPct * 1, pct);
  BL.spin(fwd, arcadeLeftPct * 1, pct);
  FR.spin(fwd, arcadeRightPct * 1, pct);
  BR.spin(fwd, arcadeRightPct * 1, pct);
}

void usercontrol(void) {
  DRIVER_CONTROL = true;
  Endgame.set(false);
  Angler.set(true);
  Pressure.set(false);

  Left.resetRotation();
  Side.resetPosition();

  FL.setBrake(brakeType::coast);
  FR.setBrake(brakeType::coast);
  BL.setBrake(brakeType::coast);
  BR.setBrake(brakeType::coast);
  
  // task odometryTask(positionTracking);
  // task drawFieldTask(drawField);
  // task chassisControlTask(chassisControl);
  task flywheelTask(FwControlTask);

  FlyFront.setBrake(coast);
  FlyBack.setBrake(coast);

  Brain.Screen.clearScreen();

  while (1) {
    tankDrive();
    //arcadeDrive();

    //tuneDrive();

    // if (Controller1.ButtonLeft.PRESSED){
    //   turnToPoint(30, 30, 1300, 1);
    //   waitUntil(runChassisControl == false);
    //   moveToPoint(70, 70, 3000, 0.7);
    // }
    // if (Controller1.ButtonLeft.PRESSED){
    //   turnToAngle(0, 1300);
    // }
    // if (Controller1.ButtonRight.PRESSED){
    //   turnToAngle(180, 1300);
    // }
    // if (Controller1.ButtonUp.PRESSED)
    // {
    //   driveForDist(-39, 2000, 1);
    // }
    // if (Controller1.ButtonDown.PRESSED){
    //   driveForDist(-24, 3000, 1);
    //   //turnToAngle(0, 5000);
    // }

    intakeControl();
    shooterControl();
    flywheelControl();
    //anglerControl();
    endgameControl();

    wait(20, msec);
  }
}

int main() {
  Competition.bStopAllTasksBetweenModes = true;
  Competition.autonomous(autonomous);
  Competition.drivercontrol(usercontrol);

  pre_auton();

  // std::cout << "----------------------------------------------------------------------------------------------------------------" << std::endl << std::endl;

  while(Inertial.isCalibrating()) {
    task::sleep(100);
  }

  Controller1.rumble("-");
  
  while (true) {
    wait(100, msec);
  }
}
